---
title: "Report_Draft"
author: "Allen Wang"
date: '2022-05-26'
output:
  html_document:
    toc: yes
    toc_float: yes
    code_folding: show
  pdf_document:
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE,
                      warning = FALSE)
```

```{r include=FALSE}
library(modeltime)
library(tidymodels)
library(tidyverse)
library(timetk)
library(lubridate)
library(tidycensus)
library(tidyverse)
library(dplyr)
library(tigris)
library(xts)
library(forecast)
library(zoo)
library(corrplot)
library(prophet)
library(plotly)
library(rules)
options(tigris_use_cache = TRUE)
```

# What is the unemployment rate?
First, we must know what is the definition of the unemployment rate to understand how it is derived and what factors are related to it. A person is defined as **unemployed** in the United States if they are jobless, but have looked for work in the last four weeks and are available for work. To record unemployed, Government distributes survey to sampling population and predict the entire unemployed number in a broad area. Measuring the unemployment gives us a good overview of the ongoing status of the economy, international competition, technology development, and so on.

The equation of the **Unemployment Rate** is 

$$unemployment \space rate = \frac{unemployed}{labor \space force}\times100$$
where _labor force_ includes all people age 16 and older who are classified as either employed and unemployed.

In this project, I will focus on analyzing and predicting the unemployment rate in the LA County. 

# Data Cleaning 
```{r}
unprocessed = read.csv("D:/UCSB/Spring_2022/PSTAT 131/PSTAT_131_HW/HW2/PSTAT-131/Final Project/data/unprocessed_data.csv")
head(unprocessed)
```

Although all variables are supposed to be numeric, but in fact some of them are imported as character variables. Also, we need to deal with missing value in columns contained "PCH" which means "Percent Change".

```{r}
unprocessed = unprocessed[-1,]
date = unprocessed[,1]

# delete NA in the first row 
unprocessed = unprocessed[,-1] %>% mutate_if(is.character, as.numeric)

unprocessed$DATE = date
unprocessed = unprocessed %>%
  select(DATE, everything())

# delete variables that have at least 8 missing values 
processed_data = unprocessed %>% select(-avg_price_pipedgas_la, -new_patent_ass_la,
                                     -cpi_allitems_la, -us_interest_rate,
                                     -economics_cond_index_la) %>% 
  head(-2)

sapply(processed_data, function(x) sum(is.na(x)))
```

```{r}
write.csv(processed_data, "D:\\UCSB\\Spring_2022\\PSTAT 131\\PSTAT_131_HW\\HW2\\PSTAT-131\\Final Project\\data\\processed_data.csv", row.names = FALSE)
```


# EDA 
```{r}
# start with Feb since we delete the first row of unprocessed data
processed = ts(unprocessed[,-1],frequency = 12, start = c(1990,2)) 

autoplot.zoo(processed[,"unemploy_rate_la"])+
  ggtitle("Unemployment Rate in LA County") +
  xlab("Year") +
  ylab("Percentage%")
```
We discovered that there are a few well-known recession periods from 1990 to now. The collapse of internet bubble, the financial crisis of 2007, and Covid-19 pandemic all matches severe increase of the unemployment rate. We may study how different economics indexes fluctuates during the financial crisis of 2007 which is mainly caused by the mortgage debt.  


Now we want to discover the seasonal pattern of the unemployment. Except the fluctuation during the Covid-19 seems abnormal, we discover that the unemployment rate usually peaks in summer. This is a problem requires further research. 
```{r}
ggseasonplot(processed[,"unemploy_rate_la"]) +
  ggtitle("Seasonal Plot of Unemployment Rate in LA County") +
  xlab("Year") +
  ylab("Percentage%")
```

```{r}
ggsubseriesplot(processed[,"unemploy_rate_la"]) +
  ylab("$ million") +
  ggtitle("Seasonal subseries plot: LA Unemployment Rate")
```

## Spatial Analysis

Net Migration
```{r}
census_api_key("7540e4d61b8467521425225cbe8f44f7c1667f9a")
net_migration <- get_estimates(geography = "county", state = "CA",
                               variables = "RNETMIG",
                               year = 2019,
                               geometry = TRUE,
                               resolution = "20m") %>%
  shift_geometry()

order = c("-15 and below", "-15 to -5", "-5 to +5", "+5 to +15", "+15 and up")

net_migration <- net_migration %>%
  mutate(groups = case_when(
    value > 15 ~ "+15 and up",
    value > 5 ~ "+5 to +15",
    value > -5 ~ "-5 to +5",
    value > -15 ~ "-15 to -5",
    TRUE ~ "-15 and below"
  )) %>%
  mutate(groups = factor(groups, levels = order))

state_overlay <- states(
  cb = TRUE,
  resolution = "20m"
) %>%
  filter(GEOID != "72") %>%
  shift_geometry()

ggplot() +
  geom_sf(data = net_migration, aes(fill = groups, color = groups), size = 0.1) + 
  scale_fill_brewer(palette = "PuOr", direction = -1) +
  scale_color_brewer(palette = "PuOr", direction = -1, guide = FALSE)  +
  labs(title = "Net migration per 1000 residents in CA",
       subtitle = "US Census Bureau 2019 Population Estimates",
       fill = "Rate") +
  theme_minimal(base_family = "Roboto")
```
We found LA county is losing population this 5 years. It requires further discussion how this trend will effect the unemployment rate. 

Median Age  
```{r, fig.width=6, fig.height=4}
#median age
med_age <- get_acs(state = "CA", county = "Los Angeles", geography = "tract", 
                  variables = "B01002_001", geometry = TRUE)
med_age %>%
  ggplot(aes(fill = estimate)) + 
  geom_sf(color = NA) + 
  scale_fill_viridis_c(option = "magma")
```





# Building Up Models

## Modeltime model
All modeltime algorithm must include a date-time feature.

```{r}
model_data = read.csv("D:/UCSB/Spring_2022/PSTAT 131/PSTAT_131_HW/HW2/PSTAT-131/Final Project/data/processed_data.csv")
```

I first use data from 1990-2016 to test whether these models can only use previous values of the unemployment rate and date to forecast in a satisfactory accuracy. Further, I want to utilize models which consider other economics indicators. Hopefully, I can create models that can first perceive economics situation in the US and then determine the trend of the unemployment rate.  


Good forecasts capture the genuine patterns and relationships which exist in the historical data, but do not replicate past events that will not occur again. When forecasting time series data, the aim is to estimate how the sequence of observations will continue into the future. Therefore, the main concern may be only to predict what will happen, not to know why it happens.
```{r}
data = model_data %>%
  mutate(DATE, DATE = as.Date.character(DATE))

data_2016 = data[1:320,] # I don't want to include pandemic 
data_2017 = data[321:332,]

data_2016 %>% plot_time_series(DATE, unemploy_rate_la)
 
```

Splitting the data set and creating the training and testing set
```{r}
splits <- initial_time_split(data_2016, prop = 0.9)

splits %>%
  tk_time_series_cv_plan() %>%
  plot_time_series_cv_plan(DATE, unemploy_rate_la)

train_2016 = training(splits)
test_2016 = testing(splits)
```
Correlation graph 

```{r}
train_2016 %>% select(contains("la")) %>%
  cor() %>%
  corrplot(type = "upper", tl.pos = "td",
         method = "circle", tl.cex = 0.5, tl.col = 'black',
         order = "hclust", diag = FALSE)
```
Here, we only compare the unemployment rate with economics indexes in LA and discover that the unemployment rate is highly correlated with _average price of electricity_, _average price of gasoline_, and _the number of new private housing structure issue_ in LA. Thus, I may focus on these three predictor variables when creating models. 


## Auto ARIMA 
What is ARIMA? What are its parameters?

ARIMA is a simple algorithm that uses linear model to model lags. It performs automated differencing and recursive lag forecasting. Also, we can add fourier function to simulate seasonalities. However, ARIMA is very sensitive to number of lags and forecast can be erratic. Although regularization is not implemented, the parameter search might still cost lots of time. 


According to the documentation of **Auto ARIMA**, it selects parameters based on which ever model yields the best In-sample AIC value. During refitting, if a new parameter set yields a lower AICc value, then the new model is selected. 


```{r }
# Auto ARIMA
model_fit_auto_arima <- arima_reg() %>%
    set_engine(engine = "auto_arima") %>%
    fit(unemploy_rate_la ~ DATE, 
        data = train_2016)

# w/ XREGS
model_fit_auto_arima_events <- arima_reg() %>%
    set_engine(engine = "auto_arima") %>%
    fit(unemploy_rate_la ~ DATE + avg_price_electr_kwh_La + avg_price_gasolone_la +
        new_private_housing_structure_issue_la, 
        data = train_2016)

# Calibrate
calibration_tbl <- modeltime_table(model_fit_auto_arima,
                                   model_fit_auto_arima_events) %>% 
  modeltime_calibrate(test_2016)

# Forecast test
calibration_tbl %>%
  modeltime_forecast(
    new_data = test_2016,
    actual_data = data_2016
  ) %>%
  plot_modeltime_forecast()

```


```{r}
# Accuracy Test 
calibration_tbl %>% modeltime_accuracy()
```
```{r include=FALSE}
model_fit_best_arima <- calibration_tbl %>% 
  slice(2) %>%
  pluck(".model")

write_rds(model_fit_best_arima, "models/model_fit_best_arima.rds")
```


Clearly, after adding three predictor variables in our model, we are able to forecast local peaks in the short time of period. Then, we can keep forecasting beyond 2016 data.By checking the real values, we found that the green line does a great job on forecasting the trend and the seasonality of the unemployment rate in LA county. 


```{r}
# Refit  
refit_tbl <- calibration_tbl %>%
  modeltime_refit(data_2016)

refit_tbl %>% modeltime_forecast(
  new_data = data_2017,
  actual_data = data_2016
  ) %>%
  plot_modeltime_forecast(
    .conf_interval_alpha = 0.05
  )
```



## Prophet 
_changepoint_range_: Adjusts the flexibility of the trend component by limiting to a percentage of data before the end of the time series.  
_changepoint_num_: Number of potential change points to include for modeling trend.
```{r}
#Prophet 
model_fit_prophet <- prophet_reg(
  changepoint_num = 20,
  changepoint_range = 0.9
) %>%
    set_engine(engine = "prophet") %>%
    fit(unemploy_rate_la ~ DATE, data = train_2016)

model_fit_prophet_xregs <- prophet_reg(
  changepoint_num = 20,
  changepoint_range = 0.9,
  seasonality_yearly = 1
) %>%
    set_engine(engine = "prophet") %>%
    fit(unemploy_rate_la ~ DATE + avg_price_electr_kwh_La + avg_price_gasolone_la +
        new_private_housing_structure_issue_la, data = train_2016)

modeltime_table(
  model_fit_prophet,
  model_fit_prophet_xregs
) %>% modeltime_calibrate(new_data = test_2016) %>%
  modeltime_forecast(
    new_data = test_2016,
    actual_data = data_2016
  ) %>%
  plot_modeltime_forecast(.interactive = TRUE)
```
The forecast graphs shows that the prophet model wrongly predicts the trend in the testing set. Therefore, we want to visualize the effect of key parameters on the prophet model to find out what happen. No matter what I adjust the change point range and number, the forecst graph does not change. 

```{r}
prophet_model <- model_fit_prophet$fit$models$model_1

prophet_fcst <- predict(prophet_model, 
                        newdata = train_2016)

g <- plot(prophet_model, prophet_fcst) +
  add_changepoints_to_plot(prophet_model) 
  
ggplotly(g)
```
It seems that prophet model does not discover the change of trend after 2010 and predict the unemployment rate would keep growing. I may hypothesize that the growth of unemployment rate during Mortgage Crisis is so influential that the model ignores the slightly decrease afterward. Without detecting the decrease trend at the end of training set, even the XREGS cannot save the forecast. Although the prophet model may perform well if I extend the training set, this shortcoming makes me abandon Prophet model. 

I will further test the Exponential Smoothing 

## Machine Learning Algorithmm

### Elastic Net Algorithm
Elastic Net Regression is very good at capturing trends, but we may not use it for complex patterns. Also, elastic net applies regularization to a linear regression

We know a linear regression tend to over-fit if we add many predictors 

```{r}
recipe_spec_base <- recipe(unemploy_rate_la ~., data = train_2016) %>%
  step_timeseries_signature(DATE) %>%
  # feature removal
  step_rm(matches("(iso)|(xts)|(hour)|(minute)|(second)|(am.pm)|(day)|(week)")) %>%
  # standardization
  step_normalize(matches("(index.num)|(year)|(issue)")) %>%
  # month feature is converted to dummy variables 
  step_dummy(all_nominal(), one_hot = TRUE) %>%
  # 


recipe_spec_base %>% prep() %>% juice() %>% glimpse()
```


```{r}
linear_reg(
  mode = "regression"
)
```







```{r include=FALSE}
# Boosted Auto ARIMA
model_fit_arima_boosted <- arima_boost(
    min_n = 2,
    learn_rate = 0.015
) %>%
    set_engine(engine = "auto_arima_xgboost") %>%
    fit(unemploy_rate_la ~ DATE + as.numeric(DATE) + factor(month(DATE, label = TRUE), ordered = F),
        data = training(splits))

```

```{r include=FALSE}
# Exponential Smoothing
model_fit_ets <- exp_smoothing() %>%
    set_engine(engine = "ets") %>%
    fit(unemploy_rate_la ~ DATE, data = training(splits))
```

```{r include=FALSE}
#Prophet 
model_fit_prophet <- prophet_reg() %>%
    set_engine(engine = "prophet") %>%
    fit(unemploy_rate_la ~ DATE, data = training(splits))
```

```{r include=FALSE}
# Linear Regression
model_fit_lm <- linear_reg() %>%
    set_engine("lm") %>%
    fit(unemploy_rate_la ~ as.numeric(DATE) + factor(month(DATE, label = TRUE), ordered = FALSE),
        data = training(splits))
```

```{r include=FALSE}
library(earth)
# Multivariate Adaptive Regression Spline model 
model_spec_mars <- mars(mode = "regression") %>%
    set_engine("earth") 

recipe_spec <- recipe(unemploy_rate_la ~ DATE, data = training(splits)) %>%
    step_date(DATE, features = "month", ordinal = FALSE) %>%
    step_mutate(date_num = as.numeric(DATE)) %>%
    step_normalize(date_num) %>%
    step_rm(DATE)
  
wflw_fit_mars <- workflow() %>%
    add_recipe(recipe_spec) %>%
    add_model(model_spec_mars) %>%
    fit(training(splits))
```

Add fitted models to a Model Table
```{r}
models_tbl <- modeltime_table(
    model_fit_arima_no_boost,
    model_fit_arima_boosted,
    model_fit_ets,
    model_fit_prophet,
    model_fit_lm,
    wflw_fit_mars
)

models_tbl
```
Calibrate the model to a testing set 

```{r}
calibration_tbl <- models_tbl %>%
    modeltime_calibrate(new_data = testing(splits))
calibration_tbl
```
```{r}
calibration_tbl %>%
    modeltime_forecast(
        new_data    = testing(splits),
        actual_data = data_2016
    ) %>%
    plot_modeltime_forecast(
      .legend_max_width = 25
    )
```

```{r}
calibration_tbl %>%
    modeltime_accuracy() %>%
    table_modeltime_accuracy(
        .interactive = FALSE
    )
```
It seems that 

1. need to tune hyper-parameter 
2. need cross validation 
3. Analyze the ARIMA models  
  (a) Differencing and White Noise 
  (b) acf() and pacf()
  (c) KPSS Unit Root Test
4. need to explain intuition of these functions

## Random Forest 

## Neural Network 


